import 'package:flutter/foundation.dart';
import 'package:uuid/uuid.dart';
import '../models/transaction.dart';
import '../services/supabase_service.dart';

class TransactionProvider with ChangeNotifier {
  List<Transaction> _transactions = [];
  bool _isLoading = false;
  String? _error;

  List<Transaction> get transactions => _transactions;
  bool get isLoading => _isLoading;
  String? get error => _error;
  
  List<Transaction> getExpensesByMonth(DateTime selectedMonth) {
    return _transactions.where((t) => 
      t.type == "DESPESA" && 
      t.date.year == selectedMonth.year && 
      t.date.month == selectedMonth.month
    ).toList();
  }
  
  List<Transaction> getIncomesByMonth(DateTime selectedMonth) {
    return _transactions.where((t) => 
      t.type == "ENTRADA" && 
      t.date.year == selectedMonth.year && 
      t.date.month == selectedMonth.month
    ).toList();
  }

  // Legacy getters for backward compatibility - now use current month
  List<Transaction> get expenses {
    final currentMonth = DateTime.now();
    return getExpensesByMonth(currentMonth);
  }
  
  List<Transaction> get incomes {
    final currentMonth = DateTime.now();
    return getIncomesByMonth(currentMonth);
  }

  double get totalExpenses => expenses.fold(0, (sum, t) => sum + t.amount);
  double get totalIncomes => incomes.fold(0, (sum, t) => sum + t.amount);
  double get balance => totalIncomes - totalExpenses;

  List<Transaction> getTransactionsByMonth(DateTime month) {
    return _transactions.where((t) {
      return t.date.year == month.year && t.date.month == month.month;
    }).toList();
  }

  List<Transaction> getTransactionsByCategory(String categoryId) {
    return _transactions.where((t) => t.categoryId == categoryId).toList();
  }

  List<Transaction> getTransactionsByCategoryName(String categoryName) {
    return _transactions.where((t) => t.categoryName == categoryName).toList();
  }

  Future<void> loadTransactions({DateTime? month}) async {
    if (!SupabaseService.isLoggedIn) {
      _error = 'Usuário não autenticado';
      notifyListeners();
      return;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final data = await SupabaseService.getExpenses(month: month);
      _transactions = data.map((json) => Transaction.fromSupabase(json)).toList();
      _transactions.sort((a, b) => b.date.compareTo(a.date));
    } catch (e) {
      _error = 'Erro ao carregar transações: $e';
      debugPrint('Error loading transactions: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Load current month transactions
  Future<void> loadCurrentMonthTransactions() async {
    await loadTransactions(month: DateTime.now());
  }

  // Load transactions by date range
  Future<void> loadTransactionsByDateRange(DateTime startDate, DateTime endDate) async {
    if (!SupabaseService.isLoggedIn) {
      _error = 'Usuário não autenticado';
      notifyListeners();
      return;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final data = await SupabaseService.getExpensesByDateRange(startDate, endDate);
      _transactions = data.map((json) => Transaction.fromSupabase(json)).toList();
      _transactions.sort((a, b) => b.date.compareTo(a.date));
    } catch (e) {
      _error = 'Erro ao carregar transações: $e';
      debugPrint('Error loading transactions: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> addTransaction(Transaction transaction) async {
    if (!SupabaseService.isLoggedIn) {
      _error = 'Usuário não autenticado';
      notifyListeners();
      return;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      // Create new transaction
      final newTransaction = Transaction(
        id: 0, // Auto-generated by database
        type: transaction.type,
        amount: transaction.amount,
        description: transaction.description,
        category: transaction.category,
        date: transaction.date,
        userId: transaction.userId,
      );

      final data = await SupabaseService.insertExpense(newTransaction.toSupabase());
      final savedTransaction = Transaction.fromSupabase(data);
      
      _transactions.add(savedTransaction);
      _transactions.sort((a, b) => b.date.compareTo(a.date));
    } catch (e) {
      _error = 'Erro ao adicionar transação: $e';
      debugPrint('Error adding transaction: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> updateTransaction(Transaction transaction) async {
    if (!SupabaseService.isLoggedIn) {
      _error = 'Usuário não autenticado';
      notifyListeners();
      return;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      await SupabaseService.updateExpense(transaction.id, transaction.toSupabase());
      
      final index = _transactions.indexWhere((t) => t.id == transaction.id);
      if (index != -1) {
        _transactions[index] = transaction;
        _transactions.sort((a, b) => b.date.compareTo(a.date));
      }
    } catch (e) {
      _error = 'Erro ao atualizar transação: $e';
      debugPrint('Error updating transaction: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> deleteTransaction(int id) async {
    if (!SupabaseService.isLoggedIn) {
      _error = 'Usuário não autenticado';
      notifyListeners();
      return;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      await SupabaseService.deleteExpense(id);
      _transactions.removeWhere((t) => t.id == id);
    } catch (e) {
      _error = 'Erro ao deletar transação: $e';
      debugPrint('Error deleting transaction: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Map<String, double> getCategoryTotals() {
    final Map<String, double> totals = {};
    
    for (final transaction in _transactions) {
      if (transaction.isExpense) {
        totals[transaction.category] = 
            (totals[transaction.category] ?? 0) + transaction.amount;
      }
    }
    
    return totals;
  }

  Map<String, double> getCategoryTotalsByMonth(DateTime month) {
    final Map<String, double> totals = {};
    final monthTransactions = getTransactionsByMonth(month);
    
    for (final transaction in monthTransactions) {
      if (transaction.type == "DESPESA") {
        totals[transaction.category] = 
            (totals[transaction.category] ?? 0) + transaction.amount;
      }
    }
    
    return totals;
  }

  Map<String, double> getExpensesByCategory() {
    final Map<String, double> totals = {};
    
    for (final transaction in expenses) {
      if (totals.containsKey(transaction.category)) {
        totals[transaction.category] = 
            totals[transaction.category]! + transaction.amount;
      } else {
        totals[transaction.category] = transaction.amount;
      }
    }
    
    return totals;
  }

  Map<String, double> getIncomesByCategory() {
    final Map<String, double> totals = {};
    
    for (final transaction in incomes) {
      if (totals.containsKey(transaction.category)) {
        totals[transaction.category] = 
            totals[transaction.category]! + transaction.amount;
      } else {
        totals[transaction.category] = transaction.amount;
      }
    }
    
    return totals;
  }
} 